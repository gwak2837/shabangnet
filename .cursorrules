# Cursor Rules for Shabangnet

## Tech Stack

- Next.js 16 (App Router)
- React 19
- TypeScript 5
- Tailwind CSS 4
- Drizzle ORM
- TanStack Query
- Radix UI

---

## Design Principles

Design with the principles of minimalist aesthetic, intuitive interfaces, and functional beauty as a senior designer's perspective. Follow Apple's design philosophy:

### Core Principles

1. **Clarity** - Text is legible at every size, icons are precise and lucid, adornments are subtle and appropriate. Focus on functionality drives design.

2. **Deference** - Fluid motion and crisp interface help users understand and interact with content while never competing with it.

3. **Depth** - Visual layers and realistic motion convey hierarchy, impart vitality, and facilitate understanding.

### Visual Guidelines

- **Whitespace**: Embrace generous whitespace. Let content breathe.
- **Typography**: Use clean, readable fonts with clear hierarchy.
- **Colors**: Use a restrained color palette. Primary colors should be purposeful, not decorative.
- **Animations**: Subtle, meaningful transitions that enhance UX without distraction.
- **Consistency**: Maintain visual harmony across all components and pages.

### Implementation

- Prefer simple, flat UI over complex gradients or shadows
- Use consistent spacing (Tailwind's spacing scale)
- Ensure sufficient contrast for accessibility
- Design mobile-first, then enhance for larger screens

---

## Code Style

### TypeScript

- **Never use `any` type.** Use `unknown` and narrow the type, or define proper interfaces/types.
- Prefer type inference where possible, but be explicit for function parameters and return types.
- Use strict TypeScript configuration.

```typescript
// ❌ Bad
function process(data: any) {
  return data.value
}

// ✅ Good
interface Data {
  value: string
}

function process(data: Data): string {
  return data.value
}

// ✅ Also good - use unknown and narrow
function process(data: unknown): string {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return String((data as { value: unknown }).value)
  }
  throw new Error('Invalid data')
}
```

### File Structure

- **Do not create barrel files (index.ts that re-exports).** Import directly from the source file.

```typescript
// ❌ Bad - barrel file
// src/components/index.ts
export * from './Button'
export * from './Input'
export * from './Modal'

// ❌ Bad - importing from barrel
import { Button, Input } from '@/components'

// ✅ Good - direct imports
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
```

### Colocation

- **Keep non-reusable logic close to where it's used.** Types, utilities, and constants used only in a specific component or page should be defined in that file or the same folder.

```typescript
// ❌ Bad - separating non-reusable types into a separate file
// src/types/order-form.ts
export interface OrderFormData {
  productId: string
  quantity: number
}

// src/app/orders/page.tsx
import { OrderFormData } from '@/types/order-form'

// ✅ Good - define types used only in this page within the same file
// src/app/orders/page.tsx
interface OrderFormData {
  productId: string
  quantity: number
}

export default function OrdersPage() {
  // ...
}
```

```typescript
// ❌ Bad - separating single-use utilities into lib folder
// src/lib/utils/format-order-id.ts
export function formatOrderId(id: string): string {
  return `ORD-${id.toUpperCase()}`
}

// ✅ Good - define within the component file
// src/components/orders/order-table.tsx
function formatOrderId(id: string): string {
  return `ORD-${id.toUpperCase()}`
}

export function OrderTable() {
  // uses formatOrderId
}
```

- Only move to shared folders (`lib/`, `utils/`, `types/`) when reused across multiple files.

### File Size & Feature-based Splitting

- **When a file becomes too large (500+ lines), split by feature/topic** while still keeping logic close to where it's called.
- Group related functions into feature-specific files within the same directory.

```typescript
// ❌ Bad - one massive actions.ts file with 1000+ lines
// src/actions/actions.ts
export async function createOrder() {
  /* ... */
}
export async function updateOrder() {
  /* ... */
}
export async function deleteOrder() {
  /* ... */
}
export async function sendEmail() {
  /* ... */
}
export async function setupMfa() {
  /* ... */
}
export async function validateTotp() {
  /* ... */
}
// ... 50 more functions

// ✅ Good - split by feature/topic into separate files
// src/actions/orders.ts
export async function createOrder() {
  /* ... */
}
export async function updateOrder() {
  /* ... */
}
export async function deleteOrder() {
  /* ... */
}

// src/actions/email.ts
export async function sendEmail() {
  /* ... */
}
export async function testEmailConnection() {
  /* ... */
}

// src/actions/mfa.ts
export async function setupMfa() {
  /* ... */
}
export async function validateTotp() {
  /* ... */
}
```

- Keep the split files in the same directory to maintain proximity to the feature area.
- Name files descriptively by their feature domain.

---

## API Patterns

### Server Actions vs API Routes

- **Use Server Actions (`"use server"`) for mutations** - creating, updating, or deleting data.
- **Use GET API Routes for data fetching** that requires user interaction or real-time data.

```typescript
// ✅ Good - Server Action for mutations
// src/actions/orders.ts
'use server'

export async function createOrder(data: CreateOrderInput) {
  // Create order in database
  return { success: true, orderId: '...' }
}

export async function updateOrderStatus(orderId: string, status: string) {
  // Update order status
  return { success: true }
}

export async function deleteOrder(orderId: string) {
  // Delete order
  return { success: true }
}
```

```typescript
// ✅ Good - GET Route for data fetching with query params
// src/app/api/orders/route.ts
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const status = searchParams.get('status')
  const page = searchParams.get('page')

  // Fetch and return orders
  return Response.json({ orders, total })
}
```

```typescript
// ❌ Bad - Using POST API Route for mutations
// src/app/api/orders/create/route.ts
export async function POST(request: Request) {
  const data = await request.json()
  // This should be a Server Action instead
}

// ❌ Bad - Using Server Action for complex data fetching with caching needs
// This is better suited for a GET route with proper caching headers
```

### When to Use Which

| Use Case                          | Pattern       |
| --------------------------------- | ------------- |
| Create/Update/Delete data         | Server Action |
| Form submissions                  | Server Action |
| User authentication actions       | Server Action |
| List data with filters/pagination | GET API Route |
| Search with query parameters      | GET API Route |
| Data that needs HTTP caching      | GET API Route |
| Real-time data fetching           | GET API Route |
